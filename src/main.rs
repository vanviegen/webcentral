mod acme;
mod logger;
mod project;
mod project_config;
mod server;
mod streams;

use anyhow::Result;
use clap::{Parser, Subcommand};
use std::sync::Arc;
use tokio::signal;

#[derive(Debug, Clone, Parser)]
#[command(name = "webcentral")]
#[command(about = "A reverse proxy that runs multiple web applications on a single server")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Option<Commands>,

    #[command(flatten)]
    pub config: GlobalConfig,
}

#[derive(Debug, Clone, Subcommand)]
pub enum Commands {
    /// Generate an argon2 password hash for use in [auth] config
    Hash {
        /// Password to hash
        password: String,
    },
}

#[derive(Debug, Clone, Parser)]
pub struct GlobalConfig {
    #[arg(long, help = "Create/update systemd service file and enable the service")]
    pub systemd: bool,

    #[arg(long, help = "Email for LetsEncrypt certificate registration")]
    pub email: Option<String>,

    #[arg(long, default_value_t = default_projects(), help = "Projects directory pattern")]
    pub projects: String,

    #[arg(long, default_value_t = default_config(), help = "Certificates and bindings storage directory (defaults to ~/.config/webcentral/)")]
    pub data_dir: String,

    #[arg(long, default_value = "443", help = "HTTPS port (0 to disable)")]
    pub https: u16,

    #[arg(long, value_parser = clap::value_parser!(bool), num_args = 0..=1, default_value = "true", default_missing_value = "true", help = "Enable HTTP/3 (QUIC) on HTTPS port")]
    pub http3: bool,

    #[arg(long, default_value = "80", help = "HTTP port (0 to disable)")]
    pub http: u16,

    #[arg(long, value_parser = clap::value_parser!(bool), num_args = 0..=1, default_missing_value = "true", help = "Redirect HTTP to HTTPS")]
    pub redirect_http: Option<bool>,

    #[arg(long, value_parser = clap::value_parser!(bool), num_args = 0..=1, default_value = "true", default_missing_value = "true", help = "Auto-redirect www variants")]
    pub redirect_www: bool,

    #[arg(long, value_parser = clap::value_parser!(bool), num_args = 0..=1, default_value = "true", default_missing_value = "true", help = "Use Firejail sandboxing")]
    pub firejail: bool,

    #[arg(
        long,
        default_value = "https://acme-v02.api.letsencrypt.org/directory",
        help = "ACME service endpoint"
    )]
    pub acme_url: String,

    #[arg(long, default_value = "draft-11", help = "ACME protocol version")]
    pub acme_version: String,

    #[arg(
        long,
        default_value = "28",
        help = "Number of days to keep log files (0 to disable)"
    )]
    pub prune_logs: i64,
}

fn default_projects() -> String {
    if nix::unistd::geteuid().is_root() {
        "/home/*/webcentral-projects".to_string()
    } else {
        format!(
            "{}/webcentral-projects",
            std::env::var("HOME").unwrap_or_else(|_| ".".to_string())
        )
    }
}

fn default_config() -> String {
    if nix::unistd::geteuid().is_root() {
        "/var/lib/webcentral".to_string()
    } else {
        format!(
            "{}/.webcentral",
            std::env::var("HOME").unwrap_or_else(|_| ".".to_string())
        )
    }
}

impl GlobalConfig {
    pub fn redirect_http(&self) -> bool {
        self.redirect_http
            .unwrap_or(self.https > 0 && self.http > 0)
    }
}

fn setup_systemd(_config: &GlobalConfig) -> Result<()> {
    use std::process::Command;
    use std::io::Write;
    
    // Get current binary path
    let binary_path = std::env::current_exe()
        .map_err(|e| anyhow::anyhow!("Failed to get current executable path: {}", e))?;
    let binary_path = binary_path.to_str()
        .ok_or_else(|| anyhow::anyhow!("Binary path is not valid UTF-8"))?;
    
    // Build args string from original argv (skip program name and --systemd flag)
    let args: Vec<String> = std::env::args()
        .skip(1)  // Skip program name
        .filter(|arg| arg != "--systemd")  // Skip --systemd flag
        .collect();
    let args_str = args.join(" ");
    
    // Create service file content
    let service_content = format!(
        "# This file was auto-generated by 'webcentral systemd'
# To modify, run 'sudo webcentral --systemd' again with your desired arguments

[Unit]
Description=Webcentral reverse proxy
After=network.target

[Service]
Type=simple
ExecStart={} {}
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
",
        binary_path,
        args_str
    );
    
    let service_path = "/etc/systemd/system/webcentral.service";
    
    // Stop existing service (ignore errors if it doesn't exist or isn't running)
    let _ = Command::new("systemctl")
        .arg("stop")
        .arg("webcentral")
        .status();
    
    // Write service file (requires root)
    let mut file = std::fs::File::create(service_path)
        .map_err(|e| anyhow::anyhow!("Failed to create {}: {}. Run with sudo?", service_path, e))?;
    file.write_all(service_content.as_bytes())
        .map_err(|e| anyhow::anyhow!("Failed to write service file: {}", e))?;
    
    // Reload systemd daemon
    let status = Command::new("systemctl")
        .arg("daemon-reload")
        .status()
        .map_err(|e| anyhow::anyhow!("Failed to reload systemd: {}", e))?;
    if !status.success() {
        anyhow::bail!("systemctl daemon-reload failed");
    }
    
    // Enable service
    let status = Command::new("systemctl")
        .arg("enable")
        .arg("webcentral")
        .status()
        .map_err(|e| anyhow::anyhow!("Failed to enable service: {}", e))?;
    if !status.success() {
        anyhow::bail!("systemctl enable failed");
    }
    
    // Start service
    let status = Command::new("systemctl")
        .arg("start")
        .arg("webcentral")
        .status()
        .map_err(|e| anyhow::anyhow!("Failed to start service: {}", e))?;
    if !status.success() {
        anyhow::bail!("systemctl start failed");
    }
    
    println!("Created {}", service_path);
    println!("Service enabled and started");
    println!("View logs: sudo journalctl -u webcentral -f");
    
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // Install rustls crypto provider (needed when multiple providers available, e.g. with HTTP/3)
    rustls::crypto::aws_lc_rs::default_provider()
        .install_default()
        .expect("Failed to install rustls crypto provider");

    #[cfg(feature = "console")]
    console_subscriber::init();

    let cli = Cli::parse();

    // Handle --systemd flag first
    if cli.config.systemd {
        // Must be root to manage systemd services
        if !nix::unistd::geteuid().is_root() {
            anyhow::bail!("--systemd requires root privileges. Run with sudo.");
        }
        // Validate config
        if cli.config.https > 0 && cli.config.email.is_none() {
            anyhow::bail!("--email is required when HTTPS is enabled");
        }
        return setup_systemd(&cli.config);
    }

    // Handle subcommands
    if let Some(ref command) = cli.command {
        match command {
            Commands::Hash { password } => {
                use argon2::{Argon2, PasswordHasher};
                use argon2::password_hash::SaltString;
                
                // Generate random salt bytes and encode as SaltString
                let mut salt_bytes = [0u8; 16];
                rand::fill(&mut salt_bytes);
                let salt = SaltString::encode_b64(&salt_bytes)
                    .expect("Failed to encode salt");
                let argon2 = Argon2::default();
                let hash = argon2.hash_password(password.as_bytes(), &salt)
                    .expect("Failed to hash password");
                println!("{}", hash);
                return Ok(());
            }
        }
    }

    let config = cli.config;

    if config.https > 0 && config.email.is_none() {
        anyhow::bail!("--email is required when HTTPS is enabled");
    }

    // Initialize and start the server
    let server = Arc::new(server::Server::new(config).await?);
    server.clone().start().await?;

    // Wait for shutdown signal
    signal::ctrl_c().await?;
    println!("\nReceived shutdown signal, stopping...");

    server.stop().await;
    server::stop_all_projects();

    println!("Shutdown complete");

    Ok(())
}
